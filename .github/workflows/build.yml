# GitHub Actions 工作流：自动构建跨平台的可执行文件并创建Release
#
# 设计原则:
# 1. 依赖声明化：使用根目录的 vcpkg.json 文件来管理所有 C++ 依赖，保证了环境的可复现性。
# 2. 跨平台构建与发布：通过构建矩阵（matrix）在 Windows 和 macOS 上并行构建，
#    并设立一个独立的 release 任务来整合所有产物，创建带有规范命名文件的 GitHub Release。
# 3. 自动化版本管理：每次推送到 main 分支都会自动创建一个以北京时间命名的 Release，
#    实现了持续交付（Continuous Delivery）。
#
name: 构建并发布

#-----------------------------------------------------------------------------
# 触发条件
#-----------------------------------------------------------------------------
on:
  # 1. 当代码被推送到 main 分支时自动触发
  push:
    branches: [ "main" ]
  # 2. 允许在 GitHub Actions 页面手动触发
  workflow_dispatch:

#-----------------------------------------------------------------------------
# 作业定义
#-----------------------------------------------------------------------------
jobs:
  #--- 构建作业 (build) ---
  # 此作业负责在不同操作系统上编译项目。
  build:
    # 使用构建矩阵，在 Windows 和 macOS 上并行执行此作业
    strategy:
      matrix:
        os: [windows-latest, macos-latest]
    
    # 指定运行环境
    runs-on: ${{ matrix.os }}

    steps:
      # 第1步：检出代码
      # 获取您仓库的最新代码。
      - name: 检出仓库代码
        uses: actions/checkout@v4

      # 第2步：设置 vcpkg
      # 使用 'lukka/run-vcpkg' action 来自动安装 vcpkg.json 中定义的依赖。
      - name: 通过 vcpkg 安装依赖
        uses: lukka/run-vcpkg@v11
        with:
          # 固定 vcpkg 版本，确保构建环境的稳定性与可复现性。
          vcpkgGitCommitId: 'ef7dbf94b9198bc58f45951adcf1f041fcbc5ea0'

      # 第3步：配置 CMake
      # 使用 vcpkg 的工具链文件来配置项目。
      # 'shell: bash' 确保此命令在 Windows 和 macOS 上都使用 Bash shell 执行，以统一行为。
      - name: 配置 CMake
        run: cmake -B build -S . -DCMAKE_TOOLCHAIN_FILE="$VCPKG_ROOT/scripts/buildsystems/vcpkg.cmake"
        shell: bash

      # 第4步：编译项目
      # 使用 --config Release 来构建发布版本的可执行文件。
      - name: 编译可执行文件
        run: cmake --build build --config Release

      # 第5步：上传构建产物
      # 将编译好的可执行文件作为 "artifact" 上传，以供后续的 "release" 作业使用。
      - name: 上传构建产物以供发布
        uses: actions/upload-artifact@v4
        with:
          name: build-${{ matrix.os }} # 产物名称，如 "build-windows-latest"
          path: |
            build/Release/server.exe
            build/server
          if-no-files-found: ignore # 如果特定平台找不到文件 (如 macOS 上没有 .exe)，则忽略

  #--- 发布作业 (release) ---
  # 此作业在所有构建成功后运行，负责创建最终的 GitHub Release。
  release:
    # 此作业依赖于 "build" 作业，必须在所有 build 成功后才会运行。
    needs: build
    runs-on: ubuntu-latest
    # 需要写权限来创建 GitHub Release 和上传文件。
    permissions:
      contents: write

    steps:
      # 第1步：下载 Windows 构建产物
      - name: 下载 Windows 产物
        uses: actions/download-artifact@v4
        with:
          name: build-windows-latest
          path: artifacts/windows

      # 第2步：下载 macOS 构建产物
      - name: 下载 macOS 产物
        uses: actions/download-artifact@v4
        with:
          name: build-macos-latest
          path: artifacts/macos

      # 第3步：检查下载的文件结构 (用于调试)
      - name: 显示下载文件结构
        run: ls -R artifacts

      # 第4步：准备用于发布的资源
      # 将不同目录下的产物移动到根目录并重命名，方便统一上传。
      - name: 准备发布资源
        run: |
          set -x # 打印执行的命令
          if [ -f "artifacts/windows/Release/server.exe" ]; then
            mv artifacts/windows/Release/server.exe ./server-windows.exe
          fi
          if [ -f "artifacts/macos/server" ]; then
            mv artifacts/macos/server ./server-macos
          fi
        shell: bash

      # 第5步：生成发布信息
      # 在一个独立的步骤中运行shell命令来生成标签和发布名称。
      # 这比在 action 的 'with' 块中直接内联shell命令更可靠。
      - name: 生成发布标签和名称
        run: |
          echo "RELEASE_TAG=Release-$(TZ='Asia/Shanghai' date +'%Y-%m-%d-%H%M')" >> $GITHUB_ENV
          echo "RELEASE_NAME=Release $(TZ='Asia/Shanghai' date +'%Y-%m-%d %H:%M')" >> $GITHUB_ENV
        shell: bash

      # 第6步：创建 GitHub Release
      # 使用上一步生成的环境变量来创建版本。
      - name: 创建 GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          files: |
            server-windows.exe
            server-macos
          tag_name: ${{ env.RELEASE_TAG || 'draft-tag' }}
          name: ${{ env.RELEASE_NAME || 'Draft Release' }}
          body: |
            由 commit ${{ github.sha }} 自动触发的构建产物。
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}